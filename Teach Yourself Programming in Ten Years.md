# Teach Yourself Programming in Ten Years
*Peter Norvig*
## Why is everyone in such a rush?
Walk into any bookstore, and you'll see how to *Teach Yourself Java in 24 Hours* alongside endless variations offering to teach C, SQL, Ruby, Algorithms, and so on in a few days or hours. The Amazon advanced search for [title: teach, yourself, hour, since:2000](http://www.amazon.com/gp/search/ref=sr_adv_b/?search-alias=stripbooks&unfiltered=1&field-keywords=&field-author=&field-title=teach+yourself+hours&field-isbn=&field-publisher=&node=&field-p_n_condition-type=&field-feature_browse-bin=&field-subject=&field-language=&field-dateop=After&field-datemod=&field-dateyear=2000&sort=relevanceexprank&Adv-Srch-Books-Submit.x=16&Adv-Srch-Books-Submit.y=5) and found 512 such books. Of the top ten, nine are programming books (the other is about bookkeeping). Similar result come from replacing "teach youtself" with "learn" or "hours" with "days".


The conclusion is that either people are in a big rush to learn about programming, or that programming is somehow fabulously easier to learn than anything else. Felleisen *et al.* give a nod to this trend in their book [How to Design Programs](http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html), when they say "Bad programming is easy. *Idiot* can learn it in 21 days, even if they are *dummiers.*" the Abtruse Goose comic also had [their take](http://abstrusegoose.com/249).

Let's analyze what a title like [Teach Yourself C++ in 24 Hours](http://www.amazon.com/Sams-Teach-Yourself-Hours-5th/dp/0672333317/ref=sr_1_6?s=books&ie=UTF8&qid=1412708443&sr=1-6&keywords=learn+c%2B%2B+days) could mean:
* **Teach Yourself:** In 24 hours you won't have time to write several significant programs, and learn from your successes and failures with them. You won't have time to work with an experienced programmer and understand what it is like to live in a C++ environment. In short, you won't have time to learn much. So the book can only be talking about a superficial familiarity, not a deep understanding. As Alexander Pope said, a little learning is a dangerous thing.
* **C++:** In 24 hours you might be able to learn some of the synax of C++ (if you already know another language), but you couldn't learn much about how to use the language. In short, if you were, say, a Basic programmer, you could learn to write programs in the style of Basic using C++ synax, but you couldn't learn what C++ is actually good (and bad) for. So what's the point? [Alan Perlis](http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html) once said: "A language that doesn't affect the way you think about promgramming, is not worth knowing". One possible point is that you have to learn a tiny bit of C++ (or more likely, something like JavaScript or Processing) because you need to interface with an existing tool to accomplish a specific task. But then you're not learning how to program; you're learning to accomplish that task.
* **in 24 Hours:** Unfortunately, this is not enough, as the next section shows.

## Teach Yourself Programming in Ten Years
Researchers (Bloom (1985), Bryan & Harter (1899), Hayes(1989), Simmon & Chase (1973)) have shown it takes about ten years to develop expertise in any of a wide variety of areas, including chess playing, music composition, telegraph operation, painting, piano playing, swimming, tennis, and research in neuropsychology and topology. The key is *deliberative* practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, and correnting any mistakes. Then repeat. And repeat again. There appear to be no real shortcuts: even Mozart, who was a musical prodigy at age 4, tool 13 more years before he began to produce world-class music. In another genre, the Beatles seemed to burst onto the Ed Sullivan show in 1964. But they had been playing small clubs in Liverpool and Hamburg since 1957, and while they had mass appeal early on, their first great critial success, *Sgt. Peppers,* was released in 1967.

[Malcolm Gladwell](http://www.amazon.com/Outliers-Story-Success-Malcolm-Gladwell/dp/0316017922) has popularized the idea, although he concentrates on 10000 hours, not 10 years. Henri Cartier-Bresson (1908-2004) had another metric: "Your first 10000 photographs are your worst." (He did't anticpate that with digital cameras, some people can reach that mark in a week.) True expertise may take a lifetime: Samuel Johnson (1709-1784) said "Excellence in any department can be attained only by the labor of a lifetime; it is not to be purchased at a lesser price." And Chaucer (1340-1400) complained "the lyf so short, the craft so long to lerne." Hippocrates (c. 400BC) is known for thr excerpt "ars longa, vita brevis", which is part of the longer quotation "Ars longa, vita brevis, occasio praeceps, experimentum periculosum, indicium difficile", which in English renders as "Life is short, [the] craft long, opportunity fleeting, experiment treacherous, judgment difficult." Of course, no single number can be the final answer: it doesn't seem reasonable to assume that all kills (e.g., programming, chess playing, checkers playing, and music playing) couls all require exactly the same amount of time to master, nor that all people will take exactly the same amount of time. As Prof. K. Anders Ericsson puts it, "In most domains it's remarkable how much time even the most talented individuals need in order to reach the highest levels of performance. The 10,000 hour number just give you a sense that we're talking years of 10 to 20 hours a week which those who some people would argue are the most innately talented individuals still need to get to the highest level."

## So You Want to be a Programmer
Here's my recipe for programming success:
* Get **insterested** in programming, and do some because it is fun. Make sure that it keeps being enough fun so that you will be willing to put in your  ten years/10,000 hours.

* **Program**. The best kind of learning is [learning by doing](http://www.engines4ed.org/hyperbook/nodes/NODE-120-pg.html). To put it more technically, "the maximal level of performace for individuals in a given domain is not attained automatically as a function of extended experience, but the level of performance can be increased even by highly experienced individuals as a result of deliberate efforts to improve." (p. 366) and "the most effective learning require a well-defined task with an appropriate diffculty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors." (p. 20-21) The book [Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life](http://www.amazon.com/exec/obidos/ASIN/0521357349) is an interesting reference for this viewpoint.

* **Talk with** other programmers; read other programs. This is more important than any book or training course.

* If you want, put in four years at a **college** (or more at a graduate school). This will give you access to some jobs that require credentials, and it will give you a deeper understanding of the field, but if you don't enjoy school, you can (with some dedication) get similar experience on your own or on the job. In any case, bool learning alone won't be enough."Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter" says Eric Raymond, author of *The New Hacker's Dictionary*. One of the best programmers I ever hired had only a High School degree; he's produced a lot of [great](http://www.xemacs.org/) [software](http://www.mozilla.org/), has his own [news group](http://groups.google.com/groups?q=alt.fan.jwz&meta=site%3Dgroups), and made enough in stock options to buy his own [nightclub](http://en.wikipedia.org/wiki/DNA_Lounge).

* Work on *projects with* other programmers. Be the best programmer on some projects; be the worst on some others. When you're the best, you get to test your abilities to lead a project, and to inspire others with your vision. When you're the worst, you learn what the masters do, and you learn what they don't like to do (because they make you do it for them).

* Learn at least a half dozen **programming languages**. Include one language that emphasizes class abstractions (like Java or C++), one that emphasizes functional abstraction (like Lisp or ML or Haskell), one that supports declarative specifications (like Prolog or C++ templates), and one that emphasizes parallelism (like Clojure or GO).

